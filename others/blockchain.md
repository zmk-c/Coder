知识改变命运，这句话本身没有错，但是对于知识的一知半解可能让你的命运变得更差，搞科研是很有意义的，但是不要被学术界的思维限制了头脑，不要被程序员的思维限制了想象力。
# 区块链学习
Zlattice建链成功
![20220701165630](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220701165630.png)

三种主流加密货币的对比
![20220704103534](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220704103534.png)

### 区块链学习图谱--《区块链技术与应用》
![20220705103427](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220704140237.png)

**密码学（Hash算法和椭圆曲线签名算法）**
区块链中主要用到的密码学相关的是：1.哈希函数 2.签名（非对称加密）

哈希函数是一种从任何一种数据中创建小的数字“指纹”的方法。 散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。

比特币中哈希函数的三个特征为：1.collision resistence（抗碰撞性）2.hiding（不可逆向推导）3.puzzle friendly（比特币中的挖矿）。比特币中用的hash函数为`SHA-256`

比特币系统中首先对Message取哈希，然后再对哈希值签名

`ECC（Elliptic Curve Cryptography,椭圆曲线加密）`被公认为在指定密钥长度下最安全的加密算法,比特币中的公私钥生成以及签名算法`ECSDA`都是基于ECC的.私钥用来生成签名,公钥验证签名,可以有效的防篡改。
https://blog.csdn.net/weixin_42117918/article/details/103221756（这个理解椭圆曲线加密运算还是不错的）

在椭圆曲线加密利用了“椭圆曲线上的离散对数问题”,已知：
- 椭圆曲线E
- 椭圆曲线E上一点G（基点）
- 椭圆曲线E上一点xG（x倍的G）

求解x

给定椭圆曲线E，基点G和点xG，我们称xG为公钥，x值为私钥，根据椭圆曲线性质，“已知点xG求x的问题”则非常困难，因为只能遍历每一个x做运算。即已知私钥求公钥很简单，而已知公钥求公钥几乎不可能。
![20220705103427](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220705103427.png)

**区块的基本结构**
1. 区块（用哈希指针代替了普通指针，没有环路的情况下都可以使用哈希指针，否则造成循环依赖）
   区块主要包含区块头和区块体，区块头中主要包含的内容如下：版本号，前一个区块头的Hash，Merkle树根的Hash（对所有区块中的交易创建一颗Merkle树,并计算出树根的hash），时间戳（区块的创建时间），难度目标target（区块的工作量证明难度目标）,Nonce（用户工作量证明算法的一个扰动输入函数）等。
![20220705103427](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220704145344.png)


1. Merkle Tree（用哈希指针代替了普通指针）
   Merkle Tree的一个用途时用来提供`Merkle proof`（黄色交易所在叶节点到Merkel root路径中用到的哈希值）
   ![20220704150436](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220704150436.png)
   SPV（Simple Payment Verification,简单支付验证）借助Merkle Proof机制，只需要保存最长区块链的所有块头的情况下，就能够验证对一笔支付交易是否在存在。相比较于全节点，实现SPV的客户端称为轻节点（Light Node）。轻节点收到Merkle proof之后从下往上只能验证交易所在的分支的哈希值（**会不会有问题？** 人为制造哈希碰撞使向上反馈的总哈希值不变x 不可行，因为有collision resistence的保证）是否正确即可。

**什么是UTXO？**
区块链是一个去中心化的`账本`，比特币是基于`交易模式`的，其全节点要维护一个`UTXO（Unspent Transaction Output,未花费的交易输出）`集合，UTXO的总体的设计是基于这样一种思路，如果A要花费一笔钱比如100元，这笔钱不会凭空产生，那么必然由B先花费了100元，被A赚到这100元，然后A才能继续花费这一笔钱。这个链条的源头就是先产生这笔钱，在比特币中这被称为`铸币（coinbase）`。然后会产生这样一个链条，铸币->B->A->?整个过程从铸币开始，一直可以追溯到当前的状态，当接收到一个UTXO输入的时候，可以基于这个模型判断这笔钱有没有被在别的地方花费过。

UTXO集合中每个元素要给出产生这个输出的交易的哈希值，以及其在交易中是第几个输出。通过这两个信息，便可以定位到UTXO中的输出.

为什么要维护这样一个数据结构？为了防范“双花攻击”，判断一个交易是否合法，要查一下想要花掉的BTC是否在该集合中，只有在集合中的才是合法的。如果想要花掉的BTC不在UTXO中，那么说明这个BTC要么不存在，要么已经被花过，所以全节点需要在内存中维护一个UTXO从而便于快速检测双花攻击。

**PoW共识的基本原理**
PoW（Proof of Work,工作量证明）应用于比特币中，算力越高收益越高，依赖数学运算来获取记账权，去中心化程度高，资源消耗高，出块时间长，51%算力攻击
工作方式：第一个找到合适的nonce的节点获得记账权。节点生成新区块后广播给其他节点，其他节点对此区块进行验证，若通过验证则接受该区块，完成本轮共识，否则拒绝该区块，继续寻找合适的nonce。

此外简单扩展几种常见的共识：
1. PoS（Proof of Stake,权益证明）
   应用于以太坊中，权益（代币）越高收益越高，节点记账权获取难易程度和持有的权益成反比（也需要挖矿），减少PoW共识的资源消耗
   工作方式：每个节点在每一轮共识中只需要计算一次Hash，当拥有的权益越多，满足Hash目标的机会越大，获得记账权的机会越大。可以说，PoS是一个资源节省的共识协议。PeerCoin定义的权益除了与代币数量有关，引入了`币龄（Coin Age）`，100个代币持有两天，币龄为200，**因此持有的代币数量越多，时间越长，获得记账权的机会越大。**
2. DPoS（Delegate Proof of Work,委托权益证明机制）
   应用于EOS中，由PoS演化而来，性能高，持币者通过抵押代币获得选票选举出若干节点（超级节点）作为区块生产者（类似董事会选举），去中心化程度低
   工作方式：用户投票最多的若干节点成为出块节点。在每一轮共识中，轮流选出一个出块节点产生区块，并广播给其他的出块节点进行验证。若节点在规定时间内无完成出块，或产生无效区块，会被取消资格，取而代之的是重新投票选取新的出块节点。
3. PoA（Proof of Authority,权威证明）
   应用于以太坊联盟链，性能高（不需要挖矿），去中心程度低（几个权威节点组成一个中心），权威节点出块验证，防止双花
   工作方式：首先选举权威节点统计各节点状态，当有交易时，各节点不在互相发，而是统一发到Authority中，由权威节点来验证交易，PoA网络中的Validator验证人就是节点选举出来的Authority,Validator验证并签署交易之后，普通节点都从它那同步数据。（晶格链中选取PoA共识是每个节点都会打包，节点按顺序打包）
4. PBFT（Practical Byzantine Fault Tolerance,实用拜占庭容错）
   应用于超级账本，性能高，去中心化程度低，最大容错作恶节点数f=(n-1)/3
   工作方式：客户端节点发送交易请求给Primary主节点，主节点（负责将交易打包成区块和共识，**每轮共识过程中有且仅有一个Primary节点**）广播本次请求给其他Replica副本节点，副本节点执行三阶段共识流程之后返回消息给客户端，客户端收到来自f+1节点的相同消息之后表明共识过程已经完成。
   https://www.cnblogs.com/zmk-c/p/14535734.html（这个简单理解PBFT还是不错的）
   ![20220704113514](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220704113514.png)
5. Raft
   应用于超级账本2.0后的版本/私链，选举领导、同步数据，只能容纳故障节点不容纳作恶节点
   工作方式：选举一位Leader节点，该Leader将处理客户端请求并将数据复制到所有节点，如果节点异常或网络异常，Leader节点会一直重试直到所有日志都会正确复制到所有节点。
   https://www.cnblogs.com/zmk-c/p/14535679.html（这个理解Raft共识机制还是不错的）

常见共识算法的“不可能三角”视图（去中心化，安全性，可扩展性）现在流行混合共识去优化解决
![20220704113514](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220704114512.png)

最后，展示一下现有共识机制及其发展的分支
![20220704115825](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220704115825.png)

**区块链网络基本实现方式**
比特币工作于网络应用层，其底层（网络层）是一个P2P Overlay network（P2P覆盖网络）

比特币系统中所有节点完全平等，不像一些其他网络存在超级节点。要加入网络，至少需要知道一个种子节点，通过种子节点告知自己它所知道的节点。节点之间的通信采用了TCP协议，便于穿透防火墙。当节点离开时，只需要自行退出即可，其他节点在一定时间后仍然没有收到该节点消息，便会将其删掉。

每个节点维护一个邻居节点集合，消息传播在网络中采用洪泛法，某个节点在收到一条消息会将其发送给所有邻居节点并标记，下次再收到便不会再发送该消息。邻居节点选取随机，未考虑网络底层拓扑结构，也与现实世界物理地址无关。该网络具有极强鲁棒性，但牺牲了网络效率。

比特币网络传播属于`Best effort尽力而为`，不能保证一定传输成功。一个交易发布到网络上，未必所有节点都能收到，也未必所有节点收到交易顺序都一致。

#### 思考问题
**PoW为什么可以保证区块链的一致性？**
   比特币区块链上有一个共识——始终以最长连为主链（有效链），也即 “最长链规则”，这个规则对于工作量证明来说，主链必然是广大矿工消耗最多经济资本创造出来的链。所有不合法、不在主链上的区块，最终都会被丢弃，以此维护一个权威的公共账本,由此保证区块链的一致性。

**分叉是如何产生的？是如何解决的？**
分叉在区块链中指原来的一条链分成了两条链，分叉形成的原因主要有三种：
1. state fork：对比特币系统当前状态产生分歧导致的分叉（例如挖矿时两个节点同时发布区
2. forking attack：分叉攻击，人为故意造成的
3. protocal fork：比特币协议改变，但不能保证所有节点同时升级，如果存在少数节点未升级，也会导致分叉产生

其中protocal fork又分为`硬分叉`和`软分叉`两种：
- 硬分叉：对比特币协议新增协议，扩展新功能，未升级的旧节点会不认可这些修改，这也就对比特币协议内容产生了分歧，从而导致分叉，一个典型的例子就是对比特币区块大小的修改（1M->4M），即如果比特币中半数以上的节点更新了，新旧节点形成的链不同，成为两条平行的链。其特点是必须系统中所有节点更新软件，系统才不会产生永久性分叉。

- 软分叉：如果对BTC协议添加限制，使得原本合法交易在新交易中不合法，便会形成软分叉。（1M->0.5M）
只要系统中拥有半数以上算力节点更新软件，系统就不会产生永久性分叉。因为旧节点挖出的区块一直被抛弃，无法得到出块奖励(不在最长合法链上)。这就**倒逼旧节点升级软件**，最终会实现区块链上的所有矿工共同认可新协议，实现软件协议的升级

**比特币的安全性体现在哪些方面？**
- 首先恶意节点并不能将其他账户上的比特币转给自己，因为转账需要签名，恶意节点无法伪造其他人的签名，并且大多数诚实节点不承认其的合法性，以致该区块成为orphan block孤儿区块，对攻击者来说不仅不能偷盗其他人的比特币而且还会得不到出块奖励，浪费了挖矿成本。
- UTXO避免了double spending双花问题
- 椭圆曲线加密算法签名保证了几乎是无法伪造的，哈希函数两个特征1.collision resistence（抗碰撞性）2.hiding（不可逆向推导）

**为什么要调整挖矿难度？以及如何调整挖矿难度？**
挖矿的本质就是不断调整block header中的nonce值，使整个block header的哈希值小于等于给定的目标阈值，即`H(block header) <= target`（target越小目标难度越大）对于挖矿难度的调整，可以视为调整目标空间在整个输出空间中所占比例大小。

因为系统的总算力是越来越强的，如果不调整挖矿难度，则出块时间越来越短（**出块时间越来越短是好事吗？**）

出块时间缩短，那么交易可以很快被写入区块链，并提高了系统的响应时间，增加了区块链系统的效率。但是，出块时间并不是越短越好，首先，区块链在网络传播上具有时延，假如出块时间为1秒，但网络传播需要10秒，则会使得系统中**节点经常性处于不一致的状态，增加了系统不稳定性，且系统经常性位于分叉状态（不仅二分叉，乃至多分叉）**。分叉过多，则不利于系统达成共识，且会**造成算力分散**，使得黑客攻击成本大大降低(不再需要整个系统51%的算力)。

比特币中的主链选择协议是采用`最长链规则`，以太坊主采用的是`Ghost协议（Greedy Heaviest-Observed Sub-Tree protocl,贪婪子树协议）`（后续以太坊中详细介绍）

在BTC协议中规定，每隔`2016个区块`需要调整一次难度，根据10min产生一个新区块可以得到，大概需要14天的时间。具体调整公式如下：
![20220705143706](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220705143706.png)
这里目标阈值的上调和下调都是有`4倍`的限制。

![20220705143706](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220704140306.png)
**以太坊的发展阶段**
- Frontier（前沿）：这个阶段的版本是以太坊的基础，此时的以太坊具备了挖矿、交易以及智能合约功能模块。但是没有供普通用户使用的图形化界面，仅适合于开发者使用。所使用的共识算法是“PoW”。
- Homestead（家园）：这个阶段的以太坊网络变得更加稳定，且具备了图形界面的钱包软件。所使用的共识算法还是是“PoW”。
- Metropolis（大都会）：分有下面两个子版本
  - 拜占庭。发布了集合钱包功能以及合约发布等丰富功能的图形化界面软件“Mist”，同时也引入了很多新的技术，例如零知识证明，抽象账号等。使用的共识算法仍然是“PoW”。
  - 君士坦丁堡。使用混合共识算法“PoW + PoS”，为“宁静”做铺垫。
- Serenity（宁静）：将把以太坊的共识算法全部换成基于“PoS”的变种算法--“Casper投注共识”，它属于PoS系列。

**账户模型**
以太坊的账户区别于比特币中的UTXO的概念，其与银行个人账户模型的概念是比较相似的。以太坊中存在两种不同类型的账户：
1. EOA（Externally Owned Account,外部账户）：该类账户是由用户的公私钥控制，用户申请的地址代表一个外部账户，地址是作为控制该账户的公钥的最后20个字节（160位）导出的16进制格式，例如外部账户地址0x5f53d6B1FEc4C75B73D8A3bF0Ebc1306C439daBb，以太坊中的交易都是由外部账户发起。
2. CA（Contract Accounts,合约账户）：不能主动发起一个交易，被调用。
![20220705175543](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220705175543.png)

**以太坊中的数据结构**
1. 状态树
以太坊采用的是基于账户的模式，系统显式的维护账户的余额（需要设计一个数据结构从账户地址到账户状态的映射）直观的看来，其本质为key-value键值对，所以直观的想法便是用哈希表实现，若不考虑哈希碰撞，查询效率为常数级。但采用哈希表，难以提供Merkle proof.
**我们思考一下采取什么样的数据结构合适？我们能否像BTC中，将哈希表的内容组织为Merkle Tree？** 不可以，因为每当新区块发布时，哈希表中的内容会改变，以此又会重新构建一个Merkle tree,对于以太坊中的账户，其数量级远大于比特币的交易数量，很明显这是不现实的。（比特币区块包含的交易上限为4000个左右，实际上块中的交易只有几百，所以Merkle tree不是无限增大的。而以太坊中若采用Merkle树来组织账户信息，很明显会越来越大，实际中发生变化的数据很小部分，每次重构代价很大）
**注意：BTC系统中，虽然每个节点构建的Merkle Tree不一致（不排序），但最终是获得记账权的节点的Merkle Tree才是唯一有效的。**
**trie字典树->Patricia trie(tree)路径压缩的trie->Merkle Patricia Tree**
（对于Patricia trie来说，如果插入新的值，原本的压缩路径可能需要扩展开来。所以插入的键值分布比较稀疏的情况下，路径压缩效果比较好。）在以太坊系统中，160位的地址存在2^160 种，该数实际上已经非常大了，和账户数目相比，可以认为地址这一键值非常稀疏（防止哈希碰撞）。
因此，以太坊采用了新的数据结构`MPT（Merkle Patricia Tree,梅克尔帕特里夏树）`（采用修改过后的MPT）
![20220706105507](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220706105507.png)
每一个合约账户的存储都是一个小的MPT树
![20220706105854](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220706105854.png)
**账户的状态是怎么存储在状态树的？**（key地址,value）先使用RLP（Recursive Length Prefix）序列化编码后存储在状态树中。

2. 交易树&收据树
   交易树和收据树都是MPT，`MPT的好处是支持查找操作`，通过键值沿着树进行查找即可。**对于状态树，查找键值为账户地址；对于交易树和收据树，查找键值为交易在发布的区块中的序号**。
   每次发布一个区块时，区块中的交易会形成一棵MTP，即交易树。此外，以太坊还添加了一个收据树，每个交易执行完之后形成一个收据，记录交易相关信息。也就是说，交易树和收据树上的节点是一一对应的。（**注意**：交易树和收据树只将当前区块中的交易组织起来，而状态树将所有账户的状态都包含进去，无论这些账户是否与当前区块中交易有关系）
   交易树和收据树的用途：向轻节点提供Merkle proof；提供更加复杂的查找操作

**以太坊中的主链选择协议—GHOST协议**
以太坊中采用的`GHOST（Greedy Heaviest-Observed Sub-Tree protocl,贪婪子树协议）`用来**保障其最长合法链**（考虑了分叉的情况，给予叔块奖励及时让分叉进行合并）
GHOST协议最初版本：
假定以太坊系统存在以下情况，A、B、C、D在四个分支上，最后，随着时间推移B所在链成为最长合法链，因此A、C、D区块都作废，但为了补偿这些区块所属矿工所作的工作，给这些区块一些“补偿”，并称其为`Uncle Block叔父区块`。规定E区块在发布时可以将A、C、D叔父区块包含进来，A、C、D叔父区块可以得到出块奖励的**7/8**，而为了激励E包含叔父区块，规定E每包含一个叔父区块可以**额外得到1/32**的出块奖励。为了防止E大量包含叔父区块，规定一个区块只能**最多包含两个叔父区块**，因此E在A、C、D中最多只能包含两个区块作为自己的出块奖励。
最初版本缺陷：
  - 因为叔父区块最多只能包含两个，如图出现3个怎么办？
  - 矿工自私，故意不包含叔父区块，导致叔父区块7/8出块奖励没了，而自己仅仅损失1/32。如果甲、乙两个大型矿池存在竞争关系，那么他们可以采用故意不包含对方的叔父区块，因为这样对自己损失小而对对方损失大。

**我们将“叔父”这个概念进行扩展，“叔父”这一定义隔多少代才好呢？**
如下图所示，M为该区块链上一个区块，F为其严格意义上的叔父，E为其严格意义上的“爷爷辈”。以太坊中规定，如果M包含F辈区块，则F获得7/8出块奖励；如果M包含E辈区块，则F获得6/8出块奖励，以此类推向前。直到包含A辈区块，A获得2/8出块奖励，再往前的“叔父区块”，对于M来说就不再认可其为M的"叔父"了。对于M来说，无论包含哪个辈分的“叔父”，得到的出块奖励都是1/32出块奖励。也就是说，叔父区块的定义是和当前区块在七代之内有共同祖先才可（合法的叔父只有6辈）。
![20220706170043](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220706170043.png)

https://blog.csdn.net/RenLJ1895/article/details/122397207（这篇理解GHOST协议还不错）

**以太坊中的挖矿算法**
以太坊中设计了两个数据集，一大一小。小的为16M的cache，大的数据集为1G的database（DAG）。两种之间的关系为1G的数据集是通过16M的cache生成而来。(**为什么要设计一大一小两个数据集？** 为了便于进行验证，轻节点保存16M的cache进行验证即可，但对于挖矿来说，如果这样则大部分算力都花费在了通过Cache计算DAG上面，因此为了减少重复计算则需要存储1G大小的数据集)
- 16M cache的生成：Seed为种子节点，通过Seed进行一些运算获得第一个数，之后每个数字都是通过前一个位置的值取哈希得到的（数组中取值存在前后依赖关系）
  ![20220707092244](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220707092244.png)

- 1G DAG生成方式：大的数据集中的每个元素都是从小数据集中按照伪随机顺序读取一些元素，如第一次读取A的位置，对当前哈希值更新迭代算出下一次读取的位置B，再进行哈希值更新迭代计算出C位置元素，如此来回迭代读取`256次`，最终算出一个数作为DAG中的第一个元素，如此类推。
  ![20220707092737](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220707092737.png)
- 以太坊挖矿过程：用的是大数据集中的数，根据区块头和nonce值计算一个初始哈希值，映射到大数据集中的某个位置A，读取A位置的数以及后一个相邻位置A'的数进行运算，算得下一个位置B，读取B位置的数以及后一个相邻位置B'的数，以此类推，**迭代读取64次，共读取128个数**。最后计算出一个哈希值与挖矿难度目标阈值比较，若不符合则更换新的nonce值，重复以上操作直到计算出的哈希值符合要求或当前区块已经被挖出。
  ![20220707093857](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220707093857.png)
  
**以太坊挖矿难度调整**
比特币中的挖矿难度调整是每隔2016个区块进行调整，从而达到维持出块时间稳定在10min左右，而以太坊则不同，每个区块都有可能进行难度调整。具体如下：
![20220707105854](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220707105854.png)

**以太坊中的共识——PoS**
以太坊中的采用的共识是PoS（Proof of Stake，权益证明）的变种——`Casper the Friendly Finality Gadget(FFG)`
Casper协议引入一个概念：Validator(验证者)，一个用户想要成为Validator，需要上交一笔“保证金”，这笔保证金会被系统锁定。Validator的职责是推动系统达成共识，投票决定哪一条链成为最长合法链，投票权重取决于保证金数目。
实际中，采用两次投票的方式：`预投票`和`Commit投票`，规定每次投票结果都要获得`2/3`以上的验证者同意。在实际中，针对其进行了一些修改，两次投票在实际中只需要一次即可。

矿工挖矿会获得出块奖励，而验证者也会得到相应奖励。当然，为了防止验证者的不良行为，规定其被发现时要受到处罚。例如某个验证者“行政不作为”，不参与投票导致系统迟迟无法达成共识，这时扣掉其保证金；如果某个验证者“乱作为”，给两边都进行投票，被发现后没收全部保证金。没收的保证金被销毁，从而减少系统中货币总量。验证者存在“任期”，在任期结束后，进入“等待期”，在此期间等待其他节点检举揭发是否存在不良行为，若通过等待期，则可以取回保证金并获得一定投票奖励。

**了解DeFi、NFT的概念**
DeFi，即Decentralized Finance（去中心化金融）是一种创建于区块链上的金融，它不依赖券商、交易所或银行等金融机构提供金融工具，而是利用区块链上的智能合约进行金融活动。

一般说来，加密数字货币可分为两类：同质化代币(FT)和非同质化代币(NFT)。
FT（Fungible Token,同质化代币）：指的就是ETH、BNB等代币，在交易转账等过程中每个代币可以互换、无限拆分，无法区分。
NFT（Non-Fungible Token,非同质化代币）：指每个代币拥有独特且唯一的标识，两两不可互换，最小单位是1且不可分割，如加密猫，MEME等应用。

#### 思考问题
**账户模型和UTXO的优劣之处**
以太坊这种基于账户的模式更加符合我们日常生活中的消费习惯，而且其天然的防范了double spending双花问题,因为无需关系币的来源，每花费一次，只需从账户扣除即可。但是以太坊的账户模型也有缺点，该模型存在`replay attack重放攻击`的缺陷，例如A向B转账，过了一段时间，B将A的交易重新发布，从而导致A的钱被扣了两次。
为了防范重放攻击，开发者给账户交易`添加计数器`记录该账户交易过多少次，转账时将转账次数也计入交易的内容中。**系统中全节点维护账户余额和该计数器的交易数，从而防止本地篡改余额或进行重放攻击**。

比特币这种基于交易的模式UTXO不太符合我们日常生活中的消费习惯，此外在进行交易时必须将币一次性转出，否则为转出的一部分将会以交易费用的形式奖励给挖出区块的矿工（即在交易时至少将剩下的币转移到自己的另一个地址，这样也变相的增加了被篡改的难度），但是其很好的解决了double spending双花攻击。

**为什么要做以太坊，更换为基于账户的模型而不是沿袭BTC系统？**
比特币中支持每次更换账户，但以太坊是为了支持智能合约，而合约签订双方是需要明确且较少变化的。尤其是对于合约账户来说，需要保持稳定状态。

**PoS共识和GHOST共识的区别？**
以太坊中的共识是PoS的变种Casper共识，其中的validator节点投票决定哪一条链成为最长合法链，而GHOST协议是通过引入叔块奖励鼓励系统中出现分叉之后及时进行合并，**保障**最长合法链（而不是决定）

![20220705143706](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220704154651.png)


![20220705143706](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220704140345.png)

![20220705143706](https://raw.githubusercontent.com/zmk-c/cloudImage/master/img/20220704140432.png)

